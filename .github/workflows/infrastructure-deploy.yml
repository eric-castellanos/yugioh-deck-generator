# Infrastructure Deploy (Create or Resume)
# 
# This workflow deploys or resumes MLflow infrastructure.
# Assumes Terraform S3 backend and DynamoDB lock table already exist.
# Use infrastructure-full-destroy.yml to create backend if needed.

name: Infrastructure Deploy (Create or Resume)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev/staging/prod)'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      deployment_type:
        description: 'Deployment type: resume (from suspension) or clean_setup (from scratch)'
        required: true
        default: 'resume'
        type: choice
        options:
        - resume
        - clean_setup
      auto_approve:
        description: 'Auto-approve terraform apply'
        required: true
        default: false
        type: boolean

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1

jobs:
  terraform:
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment }}
      DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type }}

    defaults:
      run:
        working-directory: infra/terraform

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform Backend Configuration
        run: |
          # The backend is already configured in terraform.tf
          echo "Using existing backend configuration from terraform.tf"
          echo "Backend S3 bucket and DynamoDB table are assumed to exist"

      - name: Create Environment-Specific tfvars
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          
          # Create tfvars for clean setup or existing resources
          if [ "${{ env.DEPLOYMENT_TYPE }}" == "clean_setup" ]; then
            cat > ${{ env.ENVIRONMENT }}.tfvars << EOF
          environment        = "${{ env.ENVIRONMENT }}"
          region             = "${{ env.AWS_REGION }}"
          db_password        = "${{ secrets.MLFLOW_DB_PASSWORD }}"
          bucket_name        = "mlflow-backend-${{ env.ENVIRONMENT }}"
          mlflow_user        = "mlflow-user-${{ env.ENVIRONMENT }}"
          existing_resources = false
          account_id         = "${ACCOUNT_ID}"
          github_actions_role_arn = "${{ secrets.AWS_ROLE_TO_ASSUME }}"
          EOF
          else
            # Use existing tfvars for existing resources
            cp terraform.tfvars ${{ env.ENVIRONMENT }}.tfvars
          fi

      - name: Validate Terraform Configuration
        run: |
          echo "Validating Terraform configuration..."
          terraform fmt -check=true -diff=true || echo "⚠️ Terraform formatting issues detected"

      - name: Terraform Init
        run: terraform init -input=false

      - name: Terraform Plan
        id: plan
        continue-on-error: true
        run: |
          set +e
          set -o pipefail
          
          terraform plan -input=false \
            -var-file="${{ env.ENVIRONMENT }}.tfvars" \
            -var "cluster_name=mlflow-cluster" \
            -no-color \
            -out=tfplan \
            2>&1 | tee plan_output.txt
          
          PLAN_EXIT_CODE=$?
          
          # Check for state lock
          if grep -q "Error acquiring the state lock" plan_output.txt; then
            LOCK_ID=$(grep -oP 'ID:\s+\K[a-f0-9-]+' plan_output.txt | head -1)
            echo "lock_id=${LOCK_ID}" >> $GITHUB_OUTPUT
          else
            echo "lock_id=" >> $GITHUB_OUTPUT
          fi
          
          echo "plan_success=$([ $PLAN_EXIT_CODE -eq 0 ] && echo true || echo false)" >> $GITHUB_OUTPUT
          exit $PLAN_EXIT_CODE

      - name: Terraform Force Unlock (if needed)
        if: ${{ steps.plan.outputs.lock_id != '' }}
        run: terraform force-unlock -force ${{ steps.plan.outputs.lock_id }}

      - name: Terraform Plan (retry after unlock)
        if: ${{ steps.plan.outputs.plan_success == 'false' && steps.plan.outputs.lock_id != '' }}
        run: |
          terraform plan -input=false \
            -var-file="${{ env.ENVIRONMENT }}.tfvars" \
            -var "cluster_name=mlflow-cluster" \
            -out=tfplan

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: |
            infra/terraform/tfplan
            infra/terraform/plan_output.txt
            infra/terraform/${{ env.ENVIRONMENT }}.tfvars

      - name: Terraform Apply
        if: ${{ github.event.inputs.auto_approve == 'true' }}
        run: terraform apply -auto-approve tfplan

      - name: Wait for Manual Approval
        if: ${{ github.event.inputs.auto_approve == 'false' }}
        run: |
          echo "::notice::Terraform plan completed. Manual approval required for apply."
          echo "::notice::Download the plan artifact and run 'terraform apply tfplan' manually."
