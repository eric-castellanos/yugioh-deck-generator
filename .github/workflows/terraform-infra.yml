name: Terraform Infrastructure

on:
  workflow_dispatch:
    inputs:
      recreate:
        description: 'Recreate existing resources if they exist'
        required: false
        default: false
        type: boolean
      action:
        description: 'Action to perform (plan/apply/destroy)'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      environment:
        description: 'Environment (dev/prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
      source_dir:
        description: 'Source directory for Terraform files'
        required: true
        default: 'infra/terraform'
        type: string
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1

jobs:
  terraform:
    name: Terraform
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash
        working-directory: ${{ github.workspace }}/${{ github.event.inputs.source_dir || 'infra/terraform' }}
    env:
      TF_ACTION: ${{ github.event.inputs.action || 'plan' }}
      TF_SOURCE_DIR: ${{ github.event.inputs.source_dir || 'infra/terraform' }}
      ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false  # Disable wrapper to avoid issues with shell commands

      - name: Create terraform.tfvars
        run: |
          # Create the file with a temporary placeholder for password
          cat > terraform.tfvars <<EOF
          environment = "${{ env.ENVIRONMENT }}"
          cluster_name = "mlflow-cluster-${{ env.ENVIRONMENT }}"
          db_password = "temporarily_replaced_password"
          region = "${{ env.AWS_REGION }}"
          EOF
          
          # Replace the placeholder with actual password using sed to avoid GitHub Actions workflow syntax issues
          sed -i "s/temporarily_replaced_password/${{ secrets.DB_PASSWORD }}/g" terraform.tfvars
          
          # Display the tfvars file (without showing sensitive values)
          cat terraform.tfvars | grep -v "db_password"

      - name: Terraform Init
        id: terraform_init
        run: |
          terraform init -upgrade
          INIT_STATUS=$?
          if [ $INIT_STATUS -ne 0 ]; then
            echo "Terraform init failed. Check the logs for more details."
            exit $INIT_STATUS
          fi
        
      - name: Detect and Import Existing Resources
        id: import_resources
        if: ${{ env.TF_ACTION == 'apply' }}
        run: |
          echo "Checking for existing resources in ${{ env.ENVIRONMENT }} environment..."
          echo "Current timestamp: $(date -u "+%Y-%m-%d %H:%M:%S")"
          echo "Running as user: $(whoami)"

          # RDS Database
          DB_INSTANCE_ID="mlflow-db-${{ env.ENVIRONMENT }}"
          echo "Checking for RDS instance: $DB_INSTANCE_ID"
          if aws rds describe-db-instances --db-instance-identifier "$DB_INSTANCE_ID" >/dev/null 2>&1; then
            echo "Found existing RDS instance: $DB_INSTANCE_ID"
            if ! terraform state list module.rds.aws_db_instance.mlflow_db 2>/dev/null; then
              echo "Importing RDS instance..."
              terraform import module.rds.aws_db_instance.mlflow_db "$DB_INSTANCE_ID"
            fi
          fi

          # EKS Cluster
          CLUSTER_NAME="mlflow-cluster-${{ env.ENVIRONMENT }}"
          echo "Checking for EKS cluster: $CLUSTER_NAME"
          if aws eks describe-cluster --name "$CLUSTER_NAME" >/dev/null 2>&1; then
            echo "Found existing EKS cluster: $CLUSTER_NAME"
            if ! terraform state list module.eks.aws_eks_cluster.mlflow_cluster 2>/dev/null; then
              terraform import module.eks.aws_eks_cluster.this[0] "$CLUSTER_NAME"
            fi
          fi

          # EKS Log Group
          LOG_GROUP_NAME="/aws/eks/${CLUSTER_NAME}/cluster"
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP_NAME" | grep -q "$LOG_GROUP_NAME"; then
            echo "Found EKS log group: $LOG_GROUP_NAME"
            if ! terraform state list module.eks.aws_cloudwatch_log_group.this[0] 2>/dev/null; then
              terraform import module.eks.aws_cloudwatch_log_group.this[0] "$LOG_GROUP_NAME"
            fi
          fi

          # EKS Node Group IAM Role
          if aws iam get-role --role-name "eks_node_group" >/dev/null 2>&1; then
            echo "Found EKS IAM role: eks_node_group"
            if ! terraform state list module.eks.aws_iam_role.eks_node_group 2>/dev/null; then
              terraform import module.eks.aws_iam_role.eks_node_group "eks_node_group"
            fi
          fi

          # KMS Key
          KMS_KEY_ID="5dd32b2c-2af3-443b-b016-6aa30c16b6a6"
          echo "Checking for KMS Key: $KMS_KEY_ID"
          if aws kms describe-key --key-id "$KMS_KEY_ID" >/dev/null 2>&1; then
            if ! terraform state list module.eks.aws_kms_key.this[0] 2>/dev/null; then
              terraform import module.eks.aws_kms_key.this[0] "$KMS_KEY_ID"
            fi
          fi

          # KMS Alias
          KMS_ALIAS="alias/eks/${CLUSTER_NAME}"
          echo "Checking for KMS Alias: $KMS_ALIAS"

          if aws kms list-aliases | grep -q "$KMS_ALIAS"; then
            echo "KMS alias exists: $KMS_ALIAS"
            
            if ! terraform state list | grep -q 'module.eks.aws_kms_alias.this\[0\]'; then
              echo "Importing KMS alias into Terraform state..."
              terraform import module.eks.aws_kms_alias.this[0] "$KMS_ALIAS"
            else
              echo "KMS alias already exists in Terraform state."
            fi
          else
            echo "KMS alias not found: $KMS_ALIAS"
          fi

          # S3 Bucket
          BUCKET_NAME="mlflow-backend-${{ env.ENVIRONMENT }}"
          echo "Checking for S3 bucket: $BUCKET_NAME"
          if aws s3api head-bucket --bucket "$BUCKET_NAME" >/dev/null 2>&1; then
            if ! terraform state list module.s3.aws_s3_bucket.mlflow_bucket[0] 2>/dev/null; then
              terraform import module.s3.aws_s3_bucket.mlflow_bucket[0] "$BUCKET_NAME"
            fi
          fi

          # IAM User
          if aws iam get-user --user-name "mlflow-user" >/dev/null 2>&1; then
            if ! terraform state list module.s3.aws_iam_user.mlflow_user[0] 2>/dev/null; then
              terraform import module.s3.aws_iam_user.mlflow_user[0] "mlflow-user"
            fi
          fi

          # IAM Policy
          POLICY_ARN="arn:aws:iam::256995722813:policy/mlflow-s3-access"
          if aws iam get-policy --policy-arn "$POLICY_ARN" >/dev/null 2>&1; then
            if ! terraform state list module.s3.aws_iam_policy.mlflow_s3_policy[0] 2>/dev/null; then
              terraform import module.s3.aws_iam_policy.mlflow_s3_policy[0] "$POLICY_ARN"
            fi
          fi

          echo "Resource detection and import completed."
      
      - name: Terraform Plan
        id: terraform_plan
        if: ${{ env.TF_ACTION == 'plan' || github.event_name != 'workflow_dispatch' }}
        run: |
          echo "Running terraform plan for ${{ env.ENVIRONMENT }} environment"
          
          # Verify terraform is properly set up
          terraform -v
          
          # Run the plan with proper error handling
          terraform plan -input=false -var-file=terraform.tfvars
          PLAN_STATUS=$?
          
          if [ $PLAN_STATUS -ne 0 ]; then
            echo "Terraform plan failed. Check the logs for more details."
            exit $PLAN_STATUS
          fi
        
      - name: Terraform Validate
        id: terraform_validate
        run: |
          echo "Validating Terraform configuration..."
          terraform validate
          VALIDATE_STATUS=$?
          
          if [ $VALIDATE_STATUS -ne 0 ]; then
            echo "Terraform validation failed. Please check your configuration files."
            exit $VALIDATE_STATUS
          else
            echo "Terraform configuration is valid!"
          fi
          
      - name: Terraform Apply
        id: terraform_apply
        if: ${{ env.TF_ACTION == 'apply' }}
        run: |
          echo "Running terraform apply for ${{ env.ENVIRONMENT }} environment"
          
          # Verify terraform is properly set up before applying
          terraform -v
          
          # Run the apply with proper error handling
          echo "Applying terraform configuration..."
          
          # Capture output to analyze for common errors
          APPLY_OUTPUT=$(terraform apply -auto-approve -input=false -var-file=terraform.tfvars 2>&1) || APPLY_STATUS=$?
          
          # Check for already exists errors
          if echo "$APPLY_OUTPUT" | grep -q "already exists"; then
            echo "Some resources already exist but weren't properly imported. Check import step logs."
            echo "$APPLY_OUTPUT"
            
            if [ "${{ github.event.inputs.recreate }}" == "true" ]; then
              echo "Recreate flag is set. Attempting to continue despite errors..."
              echo "$APPLY_OUTPUT"
            else
              echo "Use the 'recreate' option if you want to replace existing resources."
              exit 1
            fi
          elif [ ! -z "$APPLY_STATUS" ]; then
            echo "$APPLY_OUTPUT"
            echo "Terraform apply failed with status: $APPLY_STATUS"
            exit $APPLY_STATUS
          else
            echo "$APPLY_OUTPUT"
            echo "Terraform apply completed successfully!"
            
            # Output some useful information about the created resources
            echo "Outputting created resource information:"
            terraform output
          fi
          
      - name: Terraform Destroy
        id: terraform_destroy
        if: ${{ env.TF_ACTION == 'destroy' }}
        run: |
          echo "Running terraform destroy for ${{ env.ENVIRONMENT }} environment"
          
          # Confirm destruction intent in logs
          echo "WARNING: About to destroy all resources in ${{ env.ENVIRONMENT }} environment"
          
          # Run the destroy with proper error handling
          terraform destroy -auto-approve -input=false -var-file=terraform.tfvars
          DESTROY_STATUS=$?
          
          if [ $DESTROY_STATUS -ne 0 ]; then
            echo "Terraform destroy failed. Check the logs for more details."
            exit $DESTROY_STATUS
          else
            echo "Terraform destroy completed successfully. All resources have been removed."
          fi